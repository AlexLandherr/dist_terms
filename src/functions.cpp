#include "include/functions.h"
#include <string>
#include <vector>
#include <algorithm>
#include <cstdint>

/*
Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2 = 4, 2^3 = 8, 2^4 = 16, 2^5 = 32
3^2 = 9, 3^3 = 27, 3^4 = 81, 3^5 = 243
4^2 = 16, 4^3 = 64, 4^4 = 256, 4^5 = 1024
5^2 = 25, 5^3 = 125, 5^4 = 625, 5^5 = 3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125.

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
*/

namespace func {
    std::string add_num_str(std::string &str1, std::string &str2) {
        std::string result;
        //Making sure number strings are equally long.
        if (str1.length() > str2.length()) {
            str2.insert(0, (str1.length() - str2.length()), '0');
        } else if (str2.length() > str1.length()) {
            str1.insert(0, (str2.length() - str1.length()), '0');
        }

        //Adding number strings together, one digit at a time from right to left.
        int carry = 0;
        for (int i = static_cast<int>(str1.length()) - 1; i >= 0; i--) {
            result.insert(0, std::to_string(((str1[i] - 48) + (str2[i] - 48) + carry) % 10));
            carry = ((str1[i] - 48) + (str2[i] - 48) + carry) / 10;
        }

        //Prepend the final carry value to the result std::string.
        if (carry > 0) {
            result.insert(0, std::to_string(carry));
        }

        return result;
    }

    std::string multiply_num_str(std::string &str1, std::string &str2) {
        /*For each digit in str1 multiply it with each digit from str2 (from right to left)
        and add the carry to said product.
            
        Then prepend the (result % 10) to a string to be inserted in a vector holding the result for
        the each digit in str1 times the corresponding one in str2.
            
        Then take the sum of the numbers in the vector to get the final product.*/
        std::string result = "0";
        std::vector<std::string> interim_results;
        
        if (str1.length() > str2.length()) {
            str2.insert(0, (str1.length() - str2.length()), '0');
        } else if (str2.length() > str1.length()) {
            str1.insert(0, (str2.length() - str1.length()), '0');
        }

        for (int i = static_cast<int>(str1.length()) - 1; i >= 0; i--) {
            uint64_t carry = 0;
            std::string current_digit_prod_str;
            std::string digit_1 = str1.substr(i, 1);

            for (int j = static_cast<int>(str2.length()) - 1; j >= 0; j--) {
                std::string digit_2 = str2.substr(j, 1);
                current_digit_prod_str.insert(0, std::to_string(((std::stoi(digit_1) * std::stoi(digit_2)) + carry) % 10));

                carry = ((std::stoi(digit_1) * std::stoi(digit_2)) + carry) / 10;
            }

            if (carry > 0) {
                current_digit_prod_str.insert(0, std::to_string(carry));
            }

            interim_results.push_back(current_digit_prod_str);
        }
        
        //Appending zeros to the end of all interrim results to make their summation be correct.
        for (int n = 0; n < static_cast<int>(interim_results.size()); n++) {
            if (n == 0) {
                continue;
            } else {
                interim_results[n] = interim_results[n].append(n, '0');
            }
        }

        if (interim_results.size() == 1) {
            result = interim_results[0];
        } else {
            for (int k = 0; k < static_cast<int>(interim_results.size()); k++) {
                result = add_num_str(result, interim_results[k]);
            }
        }
        
        //Remove leading zeros.
        result.erase(0, std::min(result.find_first_not_of('0'), result.size() - 1));

        return result;
    }
}